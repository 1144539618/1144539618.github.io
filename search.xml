<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>汪大佬第一次编程感言</title>
      <link href="2021/09/26/%E6%B1%AA%E5%A4%A7%E4%BD%AC%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BC%96%E7%A8%8B%E6%84%9F%E8%A8%80/"/>
      <url>2021/09/26/%E6%B1%AA%E5%A4%A7%E4%BD%AC%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BC%96%E7%A8%8B%E6%84%9F%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="86522a816bf43a1f83f729ec92b6a3e23d6c56571ce7346b28969735a425a322">4630436162ade97ba2718b7d0c4b3b63dc7090183d7540ee162ecb0e10eb2414d493db9f9fbe9eec2c1e72a90210a042a8cf93152091a531583522943a0e6f3de6be3901e6ef642e4199aec4bbce72b3da437eacd563222edad112a5941d1b20bc5b0af2c740c8d59d8df932b8aa463febcd42ac82eaa7904b65fcc55371468df102212b6a7fb9934a3712e6f63474c786dbad7aabd38d642f560bec016019203ac6352e93592142c26d2c3f227f81c9f8ef40ec722ddd152c770b82a5335a162daa3685d736762f247b683c68a5535e96a83a6ad5ea4960f4149817ff07600760ba2d824abc211701af2d530f4903bfbda6a9bf80471f668559dc256c81c75d245e119962fcbe9fff3a0fd84b9c9aac85e4cf1e16348307c2419ee31f61fcbf1b831dc88a5d6f6b88c2266fae005739d0fb23aa498b825b46f46ea91637fb689fb81d555fe4b3c5a74fc049b293b86084befa4b2ab5318db0f6e1cb0c37041344acd80c10294bf68eddc2a074da0a473461c693c7e939fcf87443e96c493405387efe9c333c78c15993392323a09a8582d8975f848962643fd59e2cd4463b956ee6923e15137f8b6e73c6c8fe65e18e57a27dfc369b21004eefac2ae5b7ad982a31976f9c21c03ec85a4d19e0788e37081e3d7de3ce71c5f23a36ee24975991a118fd6a4522378a462b514cc491a9c8ab0e73fb09309ed1fca6e9253c789f68f7c2fc878906e5f4c64593b86b14876094ed63cdc69220187e22c7768096c9ebfa879f5bf7fdb0e1ffc45377a910fa013764c71b97c04a16fad2c29984019ab4d598f2b2c30fcbe3bbf0a3c2d8551ed784e1d63757a1be2e6ba46683936591657d8eb53d026b3130433dbbf0b889322711fb57df4244af29936b898bbeac66ccb272dce7aab7a61126a4eedd23f8851e209669153cb25ab3e396a4f7eb61880bb22b42b89860e5e00370a0839aafdc5de8afa80f95b2d735271f773fd6d4369728b955e6da333a78fab5159cf18188492c6d9a8623032cee3266347528dc7f4232a940d3906263f267e623e353baa9a1d15e63d4af1ec86aa1a3838174c717e2ae17b107c4b0d809e709a85a736e11319b65545ae936fc4e88b1f3a7155e5de2c00f15d11fb5cabeb231e2a3bcd7772bfe9930490a83a4b659d251fc8375bb8d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Excel学习笔记</title>
      <link href="2021/07/25/Excel%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/07/25/Excel%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="快捷记忆"><a href="#快捷记忆" class="headerlink" title="快捷记忆"></a><strong>快捷记忆</strong></h1><ul><li><p>Excel最大计算精度是15位,第一种是将格式设置成文本，第二种是在输入前先输入’号开头</p></li><li><p> ctrl+Enter     快速填充</p></li><li><p> ctrl+A             全部选中</p></li><li><p> ctrl+方向键     快速向下或…</p></li><li><p> 双击边框</p></li><li><p>自定义排序：选项-&gt;高级-&gt;编辑自定义列表-&gt;导入***</p></li><li><p>*: 表示任意个字符<br> ?: 表示任意单个字符    </p></li><li><p>高级筛选：自定义筛选区域+条件进行筛选***</p></li><li><p>数据验证中设置提示信息，和错误提示等</p></li></ul><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a><strong>数据管理</strong></h1><ul><li>数据验证<ul><li>在数据验证中设置输入信息，和出错警告等<br>  <img src="https://und-picture-bed2.oss-cn-beijing.aliyuncs.com/img/excel111.png"></li><li>在数据验证中设置输入数据的要求，不符合规则进行报错<br>  <img src="https://und-picture-bed2.oss-cn-beijing.aliyuncs.com/img/excel.png"></li><li>在数据验证中设置序列，把每个选项之间用逗号隔开，进行数据输入时可直接进行选择<br>  <img src="https://und-picture-bed2.oss-cn-beijing.aliyuncs.com/img/excel33.png"></li></ul></li><li>条件格式<ul><li>突出显示单元格规则：选择重复值以及大于，等于，小于，包含某指定数据等的单元格数据</li><li>项目选取规则：选择前后%多少的数据，以及低于/高于平均值等的数据</li><li>图标集：选取图标集后在<strong>管理规则</strong>里面设置对应的规则</li><li>数据条：在单元格中显示，编辑对应的规则使数据更加突出</li><li>应用：可以应用在找出数据差异，或者查找出不重复值。差异：选定区域，在突出重复值里可换为唯一值</li></ul></li><li>表格美化<ul><li>对齐方式：<strong>跨列居中</strong></li><li>中文字体的选择尽量用无衬线字体，类似微软雅黑、<strong>微软雅黑 Light</strong>、黑体、华文细黑等。</li><li>网格线一般选择关闭，避免产生过多的视觉干扰。</li><li>标题字体一般10至14磅，正文字体大小一般8至10磅。重点内容需要加粗字体或边框标注出来。</li><li>边框根据需要可以自定义修改</li><li>用取色器进行取色，自定义颜色，输入RGB值</li><li>选择对应的数据格式,比如：会计专用</li></ul><h1 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h1></li><li>数据验证<ul><li>序列 ：用逗号隔开，输入数据时可进行选择（=参数表）</li><li>圈示无效数据 ：先通过设置规定有效数据，然后进行圈示就行</li><li>其他类型，如：整数，文本长度等根据需要自己设置</li></ul></li><li>数据库连接<ul><li>根据数据文件类型选择对应的导入方式</li><li>文本文件：要规定分割方式，每行或者每列的数据类型（时间等）</li><li>属性-&gt;刷新时间</li></ul></li><li>数据拆分-合并-转换<ul><li>拆分数据：把相应的数据填写到对应单元格中，然后ctrl+e<br>  <img src="https://und-picture-bed2.oss-cn-beijing.aliyuncs.com/img/excel1.png"></li><li>合并数据：把数据写入同一个单元格，用逗号隔开，然后ctrl+e<br>  <img src="https://und-picture-bed2.oss-cn-beijing.aliyuncs.com/img/excel2.png"></li><li>转换数值：对于汉字的转换需要手动输入两次，然后再ctrl+e<br>  <img src="https://und-picture-bed2.oss-cn-beijing.aliyuncs.com/img/excel3.png"></li></ul></li><li>数据转换(二维转一维)<ol><li>新建查询-&gt; 合并查询-&gt; 启动 Power Query 编辑器 </li><li>将数据提交到 Power Query 编辑器</li><li>选中需要转换的数据</li><li>转换选项卡 -&gt; 逆透视列 -&gt; 文件 -&gt;关闭并上载（重新导入excel表格）</li><li>原数据改变，进行刷新，转换后的表格进行对应的转换<br><img src="https://und-picture-bed2.oss-cn-beijing.aliyuncs.com/img/excel4.png"></li></ol></li></ul><h1 id="第三次直播"><a href="#第三次直播" class="headerlink" title="第三次直播"></a>第三次直播</h1><ul><li><p><strong>锁定单元格</strong> ： F4</p></li><li><p><strong>F9</strong>：查看编辑栏里的数值</p></li><li><p><strong>SUMIFS</strong>: 多条件求和</p></li><li><p><strong>COUNTIFS</strong>:多条件计数</p></li><li><p><strong>RANDBETWEEN(bottom, top)</strong>:返回bottom和top之间的随意整数</p></li><li><p><strong>VLOOKUP</strong>：四个值 (要查找的项、要查找位置、<em><strong>区域中包含要返回的值的列号</strong></em>、返回近似匹配或精确匹配 - 指示为 1/TRUE 或 0/FALSE)</p></li><li><p><strong>REPT(text, number_times)</strong>:</p><ul><li>text: 文本内容</li><li>number_times：文本重复次数</li></ul></li><li><p><strong>OFFSET(reference, rows, cols, [height], [width])</strong></p><ul><li>reference：数据区域最左上角第一个单元格</li><li>rews: 偏移行数，即左上角向下的行数</li><li>cols：偏移列数，即左上角向右的列数</li><li>height：可选。需要返回的引用的行高。 Height 必须为正数。</li><li>width：可选。 需要返回的引用的列宽。 Width 必须为正数。</li></ul></li><li><p><strong>MATCH(lookup_value, lookup_array, [match_type])</strong></p><ul><li><p>lookup_value：要匹配的值</p></li><li><p>lookup_array：匹配区域</p></li><li><p>match_type：</p></li><li><table><thead><tr><th>1 或省略</th><th align="right"><strong>MATCH</strong> 查找小于或等于 *<strong>lookup_value*</strong> 的最大值。 *<strong>lookup_array*</strong> 参数中的值必须以升序排序，例如：…-2, -1, 0, 1, 2, …, A-Z, FALSE, TRUE。</th></tr></thead><tbody><tr><td>0</td><td align="right"><strong>MATCH</strong> 查找完全等于 *<strong>lookup_value*</strong> 的第一个值。 *<strong>lookup_array*</strong> 参数中的值可按任何顺序排列。</td></tr><tr><td>-1</td><td align="right"><strong>MATCH</strong> 查找大于或等于 *<strong>lookup_value*</strong> 的最小值。 *<strong>lookup_array*</strong> 参数中的值必须按降序排列，例如：TRUE, FALSE, Z-A, …2, 1, 0, -1, -2, … 等等。</td></tr></tbody></table></li></ul></li></ul><h1 id="数据统计-高级函数套用技术应用"><a href="#数据统计-高级函数套用技术应用" class="headerlink" title="数据统计-高级函数套用技术应用"></a>数据统计-高级函数套用技术应用</h1><h2 id="Excel-四则运算："><a href="#Excel-四则运算：" class="headerlink" title="Excel 四则运算："></a>Excel 四则运算：</h2><ul><li>除了<strong>不等于</strong>表示为**&lt;&gt;**,其他跟c++一样</li></ul><h2 id="Excel-单元格行列混合引用"><a href="#Excel-单元格行列混合引用" class="headerlink" title="Excel 单元格行列混合引用"></a>Excel 单元格行列混合引用</h2><ul><li><table><thead><tr><th>相对引用和绝对引用：按F4切换引用方式。</th><th></th><th></th></tr></thead><tbody><tr><td>相对引用:</td><td>A1</td><td>复制、粘贴公式时行、列都变化</td></tr><tr><td>绝对引用:</td><td>$A$1</td><td>复制、粘贴公式时行、列都不变化</td></tr><tr><td>行绝对引用:</td><td>A$1</td><td>复制、粘贴公式时行不变化，列变化</td></tr><tr><td>列绝对引用:</td><td>$A1</td><td>复制、粘贴公式时行变化，列不变化</td></tr></tbody></table></li></ul><p><code>Tab:函数确认输入</code></p><p><code>数字类型是靠单元格右边的</code></p><h2 id="常见函数应用"><a href="#常见函数应用" class="headerlink" title="常见函数应用"></a>常见函数应用</h2><ul><li><table><thead><tr><th align="left">最大值 MAX()</th></tr></thead><tbody><tr><td align="left">最小值 MIN()</td></tr><tr><td align="left">第N大值  LARGE(区域或数组，N)</td></tr><tr><td align="left">第N小值  SMALL(区域或数组，N)</td></tr><tr><td align="left">平均值  AVERAGE(数据范围)</td></tr><tr><td align="left">排名 RANK(数字，查找区域，0：降序|1：升序)</td></tr></tbody></table></li></ul><ul><li><table><thead><tr><th>常见应用函数</th></tr></thead><tbody><tr><td>COUNT: 返回数字个数</td></tr><tr><td>COUNTA: 返回非空单元格个数</td></tr><tr><td>COUNTBLANK: 返回空单元格个数</td></tr></tbody></table></li></ul><p><code>空格可以表示区域交叉的单元格</code></p><ul><li><table><thead><tr><th>求和函数</th></tr></thead><tbody><tr><td>SUM: 返回指定区域的和</td></tr><tr><td>PRODUCT :返回指定区域相乘结果</td></tr><tr><td>SUMPRODUCT : 返回选定区域相乘之后和的结果</td></tr></tbody></table></li><li><table><thead><tr><th>条件计数函数</th></tr></thead><tbody><tr><td>COUNTIF: <strong>区域 + 条件</strong>，返回个数</td></tr><tr><td>COUNTIFS：可以输入多个<strong>区域 + 条件</strong>，返回满足所有条件得个数</td></tr></tbody></table></li></ul><ul><li><table><thead><tr><th>统计不重复得个数</th></tr></thead><tbody><tr><td>{=SUM(1/COUNTIF(条件区域，条件区域))}</td></tr><tr><td>数组公式：ctrl+shift+enter</td></tr><tr><td>注：COUNTIF(条件区域，条件区域)相当于统计出条件区域中每个单元格中元素出现的个数</td></tr></tbody></table></li></ul><ul><li><table><thead><tr><th>SUMIF(range,criteria,sum_range)</th></tr></thead><tbody><tr><td>(1)  Range  为用于条件判断的单元格区域。</td></tr><tr><td>(2)  Criteria    为确定哪些单元格将被相加求和的条件，其形式可以为数字、表达式或文本。例如，条件可以表示为  32、”32”、”&gt;32” 或 “apples”。</td></tr><tr><td>(3)  Sum_range  是需要求和的实际单元格。</td></tr><tr><td></td></tr><tr><td><strong>SUMIFS(SUM_range,criteria1,sum_range1,criteria2,sum_range2,…)</strong></td></tr><tr><td>(1)  SUM_Range  为用于条件判断的单元格区域。</td></tr><tr><td>(2)  Criteria1    为确定哪些单元格将被相加求和的条件，其形式可以为数字、表达式或文本。例如，条件可以表示为  32、”32”、”&gt;32” 或 “apples”。</td></tr><tr><td>(3)  range1  是需要求和的实际单元格。</td></tr></tbody></table></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP暑假实训</title>
      <link href="2021/07/06/CSP%E6%9A%91%E5%81%87%E5%AE%9E%E8%AE%AD/"/>
      <url>2021/07/06/CSP%E6%9A%91%E5%81%87%E5%AE%9E%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/lengender-12/p/6667934.html">进制转换</a><br><a href="https://www.cnblogs.com/wkfvawl/p/9053011.html">字符串反转</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>公式记忆</title>
      <link href="2021/05/22/%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BF%86/"/>
      <url>2021/05/22/%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<ul><li>a^3+b^3=(a+b)(a^2-ab+b^2)</li><li>a^3-b^3=(a-b)(a^2+ab+b^2)</li><li>(a+b)^3=a^3+b^3+3a^2b+3ab^2</li></ul><p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/w.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="2021/04/28/STL/"/>
      <url>2021/04/28/STL/</url>
      
        <content type="html"><![CDATA[<h1 id="erase："><a href="#erase：" class="headerlink" title="erase："></a>erase：</h1><blockquote><p>（1）erase(pos,n); 删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符</p></blockquote><blockquote><p>（2）erase(position);删除position处的一个字符(position是个string类型的迭代器)</p></blockquote><blockquote><p>（3）erase(first,last);删除从first到last之间的字符（first和last都是迭代器）</p></blockquote><h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><blockquote><p>模板类有三个模板参数：元素类型，容器类型，比较算子。</p><blockquote><p>priority_queue<int> q1;<br>priority_queue&lt;pair&lt;int,int&gt;&gt; q2;<br>priority_queue&lt;int,vector<int>,greater<int>&gt; q3;//定义优先级小的先出队<br>如果要自己定义比较算子，可以有多种方法，最常见的就是重载比较运算符，注意重载操作返回的结果是bool类型.<br>&lt;作为比较操作: 来确定优先级关系，此处表明优先级关系为按值从小到大排列，值大的优先级高，而优先级高的放在队列前面<br>&gt;操作符确定优先级关系时，表明优先级是按值从大到小排列，值小的优先级高，优先级高的放在队列前面。</int></int></int></p></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素Dijkstra</title>
      <link href="2021/04/26/%E6%9C%B4%E7%B4%A0Dijkstra/"/>
      <url>2021/04/26/%E6%9C%B4%E7%B4%A0Dijkstra/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/description/851/">原题链接</a><br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p><p><strong>输入格式</strong><br>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong><br>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出  −1 。</p><p><strong>数据范围</strong><br>1≤n≤500<br>1≤m≤105<br>图中涉及边长均不超过10000。</p><p><strong>输入样例：</strong></p><blockquote><p>3 3<br>1 2 2<br>2 3 1<br>1 3 4</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>3</p></blockquote><pre class=" language-c++"><code class="language-c++"> #include< iostream > #include< algorithm > #include< cstring > using namespace std; const int N=510; int g[N][N]; //邻接矩阵，储存边到边的距离 int dist[N]; // 源到各个点的距离 bool st[N]; // 储存是否确定最短距离  int n ,m;  int Dijkstra() {     memset (dist,0x3f,sizeof dist);     dist[1]=0;  // 第一个到第一个元素距离为0     for( int i=0;i < n;i++ )     {         int t=-1;         for(int j=1;j <= n;j++)  // 找目前距离最小得点         {             if(!st[j]&&(t==-1||dist[t] > dist[j])) // 当前的点没有确定最短路径且为最小值             {                  t=j;             }         }        st[t]=true;  // 已确定最短路径        for(int j=1;j<=n;j++)        {            dist[j]=min(dist[j],dist[t]+g[t][j]); // 比较并更新最短距离        }              }     if(dist[n]==0x3f3f3f3f) return -1; //还为无穷就返回-1     return dist[n]; }   int main() {      cin>>n>>m;      memset(g,0x3f,sizeof g); // 初始化为无穷      while(m--)      {          int x,y,z;          cin>>x>>y>>z;          g[x][y]=min(g[x][y],z);  // 可能会有重边，取最小值                }            cout << Dijkstra() << endl;      return 0; }</code></pre><p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/jdw.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathematica简单操作</title>
      <link href="2021/04/21/Mathematica%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
      <url>2021/04/21/Mathematica%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>注：Mathematica要求命令的首个字母都为大写，空格可当作乘号<br><strong>方程的建立与求解</strong></p><p>1.Element[{x, y}, Reals]  ： 声明x和y属于实数</p><p>2.FullSimplify[expr,assum] ：用假设进行化简.</p><p>3.Solve[3 a − c == 0 &amp;&amp; b − 3 d == 0 &amp;&amp; 2 (b + c) == 0, {a, b, c}](<em>需要根据建立方程</em>)</p><p>(* 下列函数为解析函数的是*)//利用函数解析的条件进行判断<br>例如：<br>u[x_, y_] := 2 * (x − 1) * y; //定义函数别忘了”<em>“<br>v[x</em>, y_] := y ^2 − x ^2 + 2 * x;<br>ux =D[u[x, y], x] //进行赋值，可便于操作<br>uy =D[u[x, y], y]<br>vx =D[v[x, y], x]<br>vy =D[v[x, y], y]<br>ux − vy(*解析的条件*)<br>uy + vx<br>Simplify[%](*解析的条件，根据需要，化简是必要的*)</p><p>N[Im[ Log[3 - 4 I]]] //使用N，对 3 - 4 i的虚部进行数值输出，使用用小数也会输出数值</p><p>FunctionExpand：对函数进行展开<br>Expand：展开表达式中的乘积和正整数幂<br>ComplexExpand：进行复展开<br><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/20210421200123.png"></p><p>(* 提取系数，利用系数相等.用命令更有广泛适应性，用人为设定也可以*)<br>Coefficient[uv2, x2]<br>Coefficient[uv2, y ^ 2]<br>Solve[Coefficient[uv1, x y] == 0 &amp;&amp;Coefficient[uv2, x2] ==  0 &amp;&amp;Coefficient[uv2, y^ 2] == 0,{a, b, c}]<br>(* 提取系数，利用系数相等解待定系数*)</p><p>Do[expr,n]<br>Do[expr,{i, max,min}]//将变量 i 从 1 递增到max，计算 expr，也可加步长<br>Do[expr,{i, max]}]将变量 i 从 1 递增到 max（步长为 1），计算 expr.</p><p>SumConvergence</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mathematica </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N皇后问题</title>
      <link href="2021/04/16/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>2021/04/16/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>废话不多说先上<a href="https://www.acwing.com/problem/content/description/845/">链接</a><br>n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击<br>到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</strong></p><p>现在给定整数 n，请你输出所有的满足条件的棋子摆法。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>共一行，包含整数 n。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。</p><p>其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。</p><p>每个方案输出完成后，输出一个空行。</p><p>注意：行末不能有多余空格。</p><p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>1≤n≤9</p><p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/20210416213615.png"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class=" language-c++"><code class="language-c++"> #include< iostream> using namespace std;  int n; const int N=20; bool col[N],dg[N],udg[N]; //保存行列对角线是否已经存在皇后 char path[N][N]; //储存合适的路径  void DFS(int u) {     if(n==u)     {         for(int i=0;i< n;i++) cout< < path[i]< < endl;  //给一个char的首地址输出一行         cout< < endl;         return;     }    for(int i = 0; i < n ;i++ )     {        if(!col[i]&&!dg[u+i]&&!udg[n-u+i])         {             path[u][i]='Q';             col[i]=dg[u+i]=udg[n-u+i]=true;            DFS(u+1);             col[i]=dg[u+i]=udg[n-u+i]=false;  //回溯，要恢复现场。             path[u][i]='.';         }     } } int main() {     cin> > n;     for(int i = 0 ;i< n ; i++)         for(int q = 0 ;q < n ; q++)         {             path[i][q]='.';        }    DFS(0);    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS</title>
      <link href="2021/04/15/DFS/"/>
      <url>2021/04/15/DFS/</url>
      
        <content type="html"><![CDATA[<p>这是<a href="https://www.acwing.com/problem/content/844/">AcWing</a>上的基础的DFS的一道题。</p><p>这里放上一些别的<a href="https://vjudge.net/contest/65959">DFS的题</a></p><p>问题描述</p><blockquote><p>给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。<br>现在，请你按照字典序将所有的排列方法输出。</p></blockquote><p>输入格式</p><blockquote><p>共一行，包含一个整数 n。</p></blockquote><p>输出格式</p><blockquote><p>按字典序输出所有排列方案，每个方案占一行。</p></blockquote><p>输入样例：</p><blockquote><p>3</p></blockquote><p>输出样例：</p><blockquote><p>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1</p></blockquote><p>代码实现：</p><pre class=" language-c++"><code class="language-c++"> #include < iostream >  using namespace std; const int N=100;// bool sti[N];//储存当前位置是否被用过了 int path[N];//储存路径 int n;//输入的个数 void DFS(int u) {    if(u==n)//到达最后(也可以理解为树的叶节点)进行输出    {        for(int i=0;i < n;i++)  cout<< path[i]<< " ";        cout << endl;        return;    } for(int i=1;i<=n;i++) {        if(!sti[i])//当前位置没用过进行下一步，如：1_ _,之后sti[1]为ture,直接操作下一个位置。        {            path[u]=i;            sti[i]=true;            DFS(u+1);            sti[i]=false;//递归回来要重新设置为false，防止回溯是数据错乱。        } } }      int main() {     cin>>n;     DFS(0);     return 0; }</code></pre><p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/awidhawi.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表逆置</title>
      <link href="2021/04/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE/"/>
      <url>2021/04/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>给你单链表的头指针 head 和两个整数&nbsp;left 和 right ，其中&nbsp;left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">https://leetcode-cn.com/problems/reverse-linked-list-ii</a><br>===========<br><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/rev2ex2.jpg"></p><p>示例1：</p><blockquote><p>输入：head = [1,2,3,4,5], left = 2, right = 4<br>输出：[1,4,3,2,5]</p></blockquote><p>示例2：</p><blockquote><p>输入：head = [5], left = 1, right = 1<br>输出：[5]</p></blockquote><p>提示：</p><blockquote><ul><li>链表中节点数目为 n</li><li>1 &lt;= n &lt;= 500</li><li>-500 &lt;= Node.val &lt;= 500</li><li>1 &lt;= left &lt;= right &lt;= n</li></ul></blockquote><p>代码实现：</p><blockquote><p>class Solution {<br>public:<br>ListNode* reverseBetween(ListNode* head, int left, int right) {</p><p>ListNode* prev=new ListNode(-1);prev-&gt;next=head;//增加空头结点，简化操作，我们用的课本也是加了空头结点的。<br>auto a=prev;<br>for(int i=0;i&lt;left-1;i++) a=a-&gt;next;<br>auto b=a-&gt;next,c=b-&gt;next;//c保留剩下的链表，b为要操作的目前结点<br>for(int i=0;i&lt;right-left;i++)<br>   {<br>auto d=c-&gt;next;<br>c-&gt;next=b;<br>b=c;//每次逆转之后b，c都向后移动一个结点<br>c=d;<br>   }<br>a-&gt;next-&gt;next=c;//将整个链表重新连起来<br>a-&gt;next=b;<br>return prev-&gt;next;//注意空头结点<br>  }<br>};</p></blockquote><p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/lallaawd.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md</title>
      <link href="2021/04/13/md/"/>
      <url>2021/04/13/md/</url>
      
        <content type="html"><![CDATA[<p><a href="https://m.runoob.com/markdown/">菜鸟教程</a><br>一.Markdown 标题<br>==============<br>1.使用#号</p><hr><p>一级标题:”#”<br>二级标题:”##”<br>以此类推……</p><h2 id="2-使用-和-号"><a href="#2-使用-和-号" class="headerlink" title="2.使用 = 和 -号"></a>2.使用 = 和 -号</h2><p>一级标题:=<br>二级标题:-</p><h1 id="二-Markdown-段落"><a href="#二-Markdown-段落" class="headerlink" title="二.Markdown 段落"></a>二.Markdown 段落</h1><h2 id="1-段落换行"><a href="#1-段落换行" class="headerlink" title="1.段落换行"></a>1.段落换行</h2><p>段落末尾使用两个以上的空格并回车<br>段落后面加上一个空格也可以表示重新开始一个段落</p><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h2><p>*斜体文字*<br>-斜体文字-<br>**粗体文字**<br>--粗体文字 --<br>***粗斜体文字***<br>---粗斜体文字---</p><h2 id="3-分隔线"><a href="#3-分隔线" class="headerlink" title="3.分隔线"></a>3.分隔线</h2><p>用三个以上的星号，减号，底线(中间可以有空格)来建立分割线，行内不能有其他东西</p><h2 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4.删除线"></a>4.删除线</h2><p>要给文字添加删除线，只需要在文字两端加上两个~~,如:<br>~~Hello~~<br><del>Hello</del></p><h2 id="5-下划线"><a href="#5-下划线" class="headerlink" title="5.下划线"></a>5.下划线</h2><p>下划线可以通过 HTML 的 &lt;u&gt; 标签来实现：&lt;u&gt;文本&lt;/u&gt;</p><h2 id="6-脚注"><a href="#6-脚注" class="headerlink" title="6.脚注"></a>6.脚注</h2><p>Markdown 脚注的格式为:[^要注明的文本]</p><p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/null7d01f886cc0be3c4.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信中的数学基础篇之复变函数</title>
      <link href="2021/04/13/%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"/>
      <url>2021/04/13/%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/awd.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 复变函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/10/hello-world/"/>
      <url>2021/04/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
