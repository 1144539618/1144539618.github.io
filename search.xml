<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>朴素Dijkstra</title>
      <link href="2021/04/26/%E6%9C%B4%E7%B4%A0Dijkstra/"/>
      <url>2021/04/26/%E6%9C%B4%E7%B4%A0Dijkstra/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/description/851/">原题链接</a><br>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p><p><strong>输入格式</strong><br>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong><br>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出  −1 。</p><p><strong>数据范围</strong><br>1≤n≤500,<br>1≤m≤105,<br>图中涉及边长均不超过10000。</p><p><strong>输入样例：</strong></p><blockquote><p>3 3<br>1 2 2<br>2 3 1<br>1 3 4</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>3</p></blockquote><pre class=" language-c++"><code class="language-c++"> #include< iostream > #include< algorithm > #include< cstring > using namespace std; const int N=510; int g[N][N]; int dist[N]; bool st[N];  int n ,m;  int Dijkstra() {     memset (dist,0x3f,sizeof dist);     dist[1]=0;     for( int i=0;i<n;i++ )     {         int t=-1;         for(int j=1;j <= n;j++)         {             if(!st[j]&&(t==-1||dist[t] > dist[j]))             {                  t=j;             }         }        st[t]=true;        for(int j=1;j<=n;j++)        {            dist[j]=min(dist[j],dist[t]+g[t][j]);        }              }     if(dist[n]==0x3f3f3f3f) return -1;     return dist[n]; }   int main() {     cin>>n>>m;      memset(g,0x3f,sizeof g);      while(m--)      {          int x,y,z;          cin>>x>>y>>z;          g[x][y]=min(g[x][y],z);                }            cout<<Dijkstra()<<endl;      return 0; }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathematica小班课</title>
      <link href="2021/04/23/Mathematica%E5%B0%8F%E7%8F%AD%E8%AF%BE/"/>
      <url>2021/04/23/Mathematica%E5%B0%8F%E7%8F%AD%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<p>要适当拆分</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mathematica </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathematica简单操作</title>
      <link href="2021/04/21/Mathematica%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
      <url>2021/04/21/Mathematica%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>注：Mathematica要求命令的首个字母都为大写，空格可当作乘号<br><strong>方程的建立与求解</strong></p><p>1.Element[{x, y}, Reals]  ： 声明x和y属于实数</p><p>2.FullSimplify[expr,assum] ：用假设进行化简.</p><p>3.Solve[3 a − c == 0 &amp;&amp; b − 3 d == 0 &amp;&amp; 2 (b + c) == 0, {a, b, c}](<em>需要根据建立方程</em>)</p><p>(* 下列函数为解析函数的是*)//利用函数解析的条件进行判断<br>例如：<br>u[x_, y_] := 2 * (x − 1) * y; //定义函数别忘了”<em>“<br>v[x</em>, y_] := y ^2 − x ^2 + 2 * x;<br>ux =D[u[x, y], x] //进行赋值，可便于操作<br>uy =D[u[x, y], y]<br>vx =D[v[x, y], x]<br>vy =D[v[x, y], y]<br>ux − vy(*解析的条件*)<br>uy + vx<br>Simplify[%](*解析的条件，根据需要，化简是必要的*)</p><p>N[Im[ Log[3 - 4 I]]] //使用N，对 3 - 4 i的虚部进行数值输出，使用用小数也会输出数值</p><p>FunctionExpand：对函数进行展开<br>Expand：展开表达式中的乘积和正整数幂<br>ComplexExpand：进行复展开<br><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/20210421200123.png"></p><p>(* 提取系数，利用系数相等.用命令更有广泛适应性，用人为设定也可以*)<br>Coefficient[uv2, x2]<br>Coefficient[uv2, y ^ 2]<br>Solve[Coefficient[uv1, x y] == 0 &amp;&amp;Coefficient[uv2, x2] ==  0 &amp;&amp;Coefficient[uv2, y^ 2] == 0,{a, b, c}]<br>(* 提取系数，利用系数相等解待定系数*)</p><p>Do[expr,n]<br>Do[expr,{i, max,min}]//将变量 i 从 1 递增到max，计算 expr，也可加步长<br>Do[expr,{i, max]}]将变量 i 从 1 递增到 max（步长为 1），计算 expr.</p><p>SumConvergence</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mathematica </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N皇后问题</title>
      <link href="2021/04/16/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>2021/04/16/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>废话不多说先上<a href="https://www.acwing.com/problem/content/description/845/">链接</a><br>n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击<br>到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</strong></p><p>现在给定整数 n，请你输出所有的满足条件的棋子摆法。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>共一行，包含整数 n。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。</p><p>其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。</p><p>每个方案输出完成后，输出一个空行。</p><p>注意：行末不能有多余空格。</p><p>输出方案的顺序任意，只要不重复且没有遗漏即可。</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>1≤n≤9</p><p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/20210416213615.png"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class=" language-c++"><code class="language-c++"> #include< iostream> using namespace std;  int n; const int N=20; bool col[N],dg[N],udg[N]; //保存行列对角线是否已经存在皇后 char path[N][N]; //储存合适的路径  void DFS(int u) {     if(n==u)     {         for(int i=0;i< n;i++) cout< < path[i]< < endl;  //给一个char的首地址输出一行         cout< < endl;         return;     }    for(int i = 0; i < n ;i++ )     {        if(!col[i]&&!dg[u+i]&&!udg[n-u+i])         {             path[u][i]='Q';             col[i]=dg[u+i]=udg[n-u+i]=true;            DFS(u+1);             col[i]=dg[u+i]=udg[n-u+i]=false;  //回溯，要恢复现场。             path[u][i]='.';         }     } } int main() {     cin> > n;     for(int i = 0 ;i< n ; i++)         for(int q = 0 ;q < n ; q++)         {             path[i][q]='.';        }    DFS(0);    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS</title>
      <link href="2021/04/15/DFS/"/>
      <url>2021/04/15/DFS/</url>
      
        <content type="html"><![CDATA[<p>这是<a href="https://www.acwing.com/problem/content/844/">AcWing</a>上的基础的DFS的一道题。</p><p>这里放上一些别的<a href="https://vjudge.net/contest/65959">DFS的题</a></p><p>问题描述</p><blockquote><p>给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。<br>现在，请你按照字典序将所有的排列方法输出。</p></blockquote><p>输入格式</p><blockquote><p>共一行，包含一个整数 n。</p></blockquote><p>输出格式</p><blockquote><p>按字典序输出所有排列方案，每个方案占一行。</p></blockquote><p>输入样例：</p><blockquote><p>3</p></blockquote><p>输出样例：</p><blockquote><p>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1</p></blockquote><p>代码实现：</p><pre class=" language-c++"><code class="language-c++"> #include < iostream >  using namespace std; const int N=100;// bool sti[N];//储存当前位置是否被用过了 int path[N];//储存路径 int n;//输入的个数 void DFS(int u) {    if(u==n)//到达最后(也可以理解为树的叶节点)进行输出    {        for(int i=0;i < n;i++)  cout<< path[i]<< " ";        cout << endl;        return;    } for(int i=1;i<=n;i++) {        if(!sti[i])//当前位置没用过进行下一步，如：1_ _,之后sti[1]为ture,直接操作下一个位置。        {            path[u]=i;            sti[i]=true;            DFS(u+1);            sti[i]=false;//递归回来要重新设置为false，防止回溯是数据错乱。        } } }      int main() {     cin>>n;     DFS(0);     return 0; }</code></pre><p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/awidhawi.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表逆置</title>
      <link href="2021/04/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE/"/>
      <url>2021/04/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>给你单链表的头指针 head 和两个整数&nbsp;left 和 right ，其中&nbsp;left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">https://leetcode-cn.com/problems/reverse-linked-list-ii</a><br>===========<br><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/rev2ex2.jpg"></p><p>示例1：</p><blockquote><p>输入：head = [1,2,3,4,5], left = 2, right = 4<br>输出：[1,4,3,2,5]</p></blockquote><p>示例2：</p><blockquote><p>输入：head = [5], left = 1, right = 1<br>输出：[5]</p></blockquote><p>提示：</p><blockquote><ul><li>链表中节点数目为 n</li><li>1 &lt;= n &lt;= 500</li><li>-500 &lt;= Node.val &lt;= 500</li><li>1 &lt;= left &lt;= right &lt;= n</li></ul></blockquote><p>代码实现：</p><blockquote><p>class Solution {<br>public:<br>ListNode* reverseBetween(ListNode* head, int left, int right) {</p><p>ListNode* prev=new ListNode(-1);prev-&gt;next=head;//增加空头结点，简化操作，我们用的课本也是加了空头结点的。<br>auto a=prev;<br>for(int i=0;i&lt;left-1;i++) a=a-&gt;next;<br>auto b=a-&gt;next,c=b-&gt;next;//c保留剩下的链表，b为要操作的目前结点<br>for(int i=0;i&lt;right-left;i++)<br>   {<br>auto d=c-&gt;next;<br>c-&gt;next=b;<br>b=c;//每次逆转之后b，c都向后移动一个结点<br>c=d;<br>   }<br>a-&gt;next-&gt;next=c;//将整个链表重新连起来<br>a-&gt;next=b;<br>return prev-&gt;next;//注意空头结点<br>  }<br>};</p></blockquote><p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/lallaawd.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md</title>
      <link href="2021/04/13/md/"/>
      <url>2021/04/13/md/</url>
      
        <content type="html"><![CDATA[<p><a href="https://m.runoob.com/markdown/">菜鸟教程</a><br>一.Markdown 标题<br>==============<br>1.使用#号</p><hr><p>一级标题:”#”<br>二级标题:”##”<br>以此类推……</p><h2 id="2-使用-和-号"><a href="#2-使用-和-号" class="headerlink" title="2.使用 = 和 -号"></a>2.使用 = 和 -号</h2><p>一级标题:=<br>二级标题:-</p><h1 id="二-Markdown-段落"><a href="#二-Markdown-段落" class="headerlink" title="二.Markdown 段落"></a>二.Markdown 段落</h1><h2 id="1-段落换行"><a href="#1-段落换行" class="headerlink" title="1.段落换行"></a>1.段落换行</h2><p>段落末尾使用两个以上的空格并回车<br>段落后面加上一个空格也可以表示重新开始一个段落</p><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h2><p>*斜体文字*<br>-斜体文字-<br>**粗体文字**<br>--粗体文字 --<br>***粗斜体文字***<br>---粗斜体文字---</p><h2 id="3-分隔线"><a href="#3-分隔线" class="headerlink" title="3.分隔线"></a>3.分隔线</h2><p>用三个以上的星号，减号，底线(中间可以有空格)来建立分割线，行内不能有其他东西</p><h2 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4.删除线"></a>4.删除线</h2><p>要给文字添加删除线，只需要在文字两端加上两个~~,如:<br>~~Hello~~<br><del>Hello</del></p><h2 id="5-下划线"><a href="#5-下划线" class="headerlink" title="5.下划线"></a>5.下划线</h2><p>下划线可以通过 HTML 的 &lt;u&gt; 标签来实现：&lt;u&gt;文本&lt;/u&gt;</p><h2 id="6-脚注"><a href="#6-脚注" class="headerlink" title="6.脚注"></a>6.脚注</h2><p>Markdown 脚注的格式为:[^要注明的文本]</p><p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/null7d01f886cc0be3c4.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信中的数学基础篇之复变函数</title>
      <link href="2021/04/13/%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"/>
      <url>2021/04/13/%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://und-picture-bed.oss-cn-beijing.aliyuncs.com/img/awd.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 复变函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/10/hello-world/"/>
      <url>2021/04/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
